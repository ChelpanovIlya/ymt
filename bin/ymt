#!/usr/bin/env perl
#
# ymt - YDB Migration Tool
#
# This script connects to a SQL-compatible database, executes a query, and converts
# the result to CSV format compatible with YDB. It supports various database drivers
# through Perl DBI and can process data with options like adding UUIDs or hashing columns.
#
# Usage:
#   ymt [options]
#
# See --help for detailed options and examples.
#
use strict;
use warnings;
use DBI;
use Data::GUID;
use Digest::MD5 qw(md5);
use POSIX qw(strftime);
use Getopt::Long;
use MIME::Base64 qw(encode_base64);
use Encode qw(encode decode);
use File::Basename qw(basename dirname);
use Term::ReadKey;
use Time::Local qw(timegm_nocheck timegm timelocal);
use open qw(:std :utf8); 
use Data::Dumper;
$Data::Dumper::Terse = 1;

our $VERSION="1.1.1";

our ($QUERY, $INPUT_FILE, $SCHEME, $OUTPUT_FILE, $DRIVER,
$ADD_ID, $HASH_COLUMNS, $STD_UUID, $ASSUME_TIMEZONE, $TZ_OFFSET,
$LIMIT, $PRINT_COLUMNS, $PRINT_SCHEME, $PRINT_RECORD, 
$HOST, $PORT, $USER, $DB, $PASSWORD,
$HELP);

$OUTPUT_FILE='auto'; 
$SCHEME='scheme.pb';
$DRIVER='Pg';
$HOST="localhost";

$HELP=!@ARGV;

GetOptions(
  'driver=s'=>\$DRIVER,
  'query|q=s'=>\$QUERY,
  'input-file|f=s'=>\$INPUT_FILE,
  'scheme|s=s'=>\$SCHEME,
	'output-file|o=s'=>\$OUTPUT_FILE,
	'add-id=s'=>\$ADD_ID,
  'hash-columns=s'=>\$HASH_COLUMNS,
  'assume-timezone=s'=>\$ASSUME_TIMEZONE,
  'std-uuid!' =>\$STD_UUID,
  
  'limit=i'=>\$LIMIT,
	'print-columns!'=>\$PRINT_COLUMNS,
	'print-scheme!'=>\$PRINT_SCHEME,
	'print-record!'=>\$PRINT_RECORD,
  
	'host|h=s'=>\$HOST,
	'port|p=i'=>\$PORT,
	'username|U=s'=>\$USER,
	'dbname|d=s'=>\$DB,
	'password=s'=>\$PASSWORD,
	
	'help' => \$HELP,
	'version' => sub { print "ymt $VERSION\n"; exit 0; },
) || die "Run 'ymt --help' for usage.\n";


if ( $HELP ) {
  print <<EOT;
ymt $VERSION -- YDB migration tool

Connects to a database, fetches data using a SQL query, and converts it into 
the CSV dump format used by YDB. The resulting file can be loaded into a YDB table using 
the ydb CLI "tools restore" command. Ymt can be used with any SQL-compatible 
database with a Perl DBI driver installed. Over 50 SQL-compatible (or SQL-accessible) 
databases can be used with Perl via DBI, thanks to native DBD:: modules and bridge 
drivers like DBD::ODBC and DBD::JDBC.


Usage: ymt [options]

Required input:
  -q, --query=STRING        SQL query to execute
  -f, --input-file=FILE     Read SQL query from file
  -s, --scheme=FILE         Path to protobuf schema file (default: scheme.pb)

Output:
  -o, --output-file=FILE    Output CSV file (default: auto → <scheme_dir>/data_00.csv)

Row processing:
      --add-id=NAME         Add a generated UUID-id column with given name
      --std-uuid            Use standard UUID format (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
                            (default: URL-safe Base64-encoded short UUID)
      --hash-columns=COLS   Replace column values with MD5-based identifiers (UUID or short format)
      --assume-timezone=TZ  Interpret input date/time values as belonging to the
                            specified time zone. Supported formats:
                              - 'local' - use system time zone
                              - '+HH:MM' or '-HH:MM' - fixed UTC offset
                            Values are converted to UTC before writing to YDB.
                            If omitted, input is assumed to be in UTC.
Database connection:
  -D, --driver=NAME         DBI driver (default: Pg)
                            Examples: mysql, Pg, SQLite, Oracle  
  -h, --host=HOST           Database host (default: localhost)
  -p, --port=PORT           Database port (default: 5432 for Pg, 3306 for MySQL)
  -U, --username=USER       Database user
  -d, --dbname=DB           Database name
      --password=PASS       Database password
                            password can be specified in YMT_PASSWORD environment variable

Debugging and introspection:
      --limit=N             Limit number of output rows
      --print-scheme        Print column names and types from scheme and exit
      --print-columns       Print column names from SQL result and exit
      --print-record        Print every SQL resultset record

Examples:
  ydb -p myydb tools dump -p users --scheme-only -o migration_backup
  ymt -U postgres --query="SELECT name as username,email FROM users" --scheme=migration_backup/users/scheme.pb --add-id=id
  ydb -p myydb tools restore -i migration_backup -p .

  ymt --scheme=backup/users/scheme.pb --print-scheme

  ymt --driver=mysql -d mydb -U scott -q "select ename as name,job,sal as salary from emp" -s=backup/employees/scheme.pb
EOT
  exit(0);
}

# parse scheme
my ($columns,$col_types)=extract_column_names_from_proto_text($SCHEME);
if ( $PRINT_SCHEME ) {
  printf "%-20s %s\n","Column","Type";
  print  "-------------------- ----------\n";
  for my $c ( @$columns ) {
    printf "%-20s %s\n",$c, $col_types->{$c};
  }
  exit(0);
}

die "Error: required option --scheme not specified\n" unless defined $SCHEME;

if ( $INPUT_FILE ) {
  $QUERY = read_file($INPUT_FILE);
} else {
  $QUERY = decode('UTF-8', $QUERY);  
}

die "Error: no query specified; use --query or --input-file\n" if ( ! $QUERY );

if ( $DRIVER eq 'Pg' ) {
  $PORT||=5432;
}
if ( $DRIVER eq 'mysql' ) {
  $PORT||=3306;
}

my $dsn = "dbi:$DRIVER:host=$HOST;port=$PORT";
if ( $DB ) {
  $dsn .= ";dbname=$DB";
}

if (defined($ASSUME_TIMEZONE)) {
  if ($ASSUME_TIMEZONE=~/^local$/i) {
    $TZ_OFFSET = local_tz_offset();
  } else {
    $TZ_OFFSET = parse_tz_offset($ASSUME_TIMEZONE);
  }
  printf STDERR "Converting date and time values to UTC using offset %s\n",format_tz_offset($TZ_OFFSET);  
} else {
  $TZ_OFFSET = 0;
}

$PASSWORD||=$ENV{YMT_PASSWORD};
if (!defined $PASSWORD) {
    if (!-t STDIN) {
        die "Password required but no terminal available (use --password or YMT_PASSWORD)\n";
    }
    print STDERR "Password for user '$USER': ";
    ReadMode('noecho');
    $PASSWORD = ReadLine(0);
    chomp $PASSWORD;
    ReadMode('restore');
    print STDERR "\n";
}

# Connect
my $dbh = DBI->connect($dsn, $USER, $PASSWORD, {
    RaiseError => 1,
    AutoCommit => 1,
    PrintError => 0,
}) or die "Cannot connect to database (driver=$DRIVER): $DBI::errstr\n";


# Prepare a query
my $sth = $dbh->prepare($QUERY) or die "Cannot prepare: $DBI::errstr\n";

# Execute the query
$sth->execute() or die "Cannot execute: $DBI::errstr\n";

# Fetch and print the column names
my $num_fields = $sth->{NUM_OF_FIELDS};
if ( $PRINT_COLUMNS ) {
  print join("\n", @{$sth->{NAME}}), "\n";
  exit(0);
}

# open output file
my $out;
if ( $OUTPUT_FILE eq 'auto' ) {
  my $dir=dirname($SCHEME);
  $OUTPUT_FILE = "$dir/data_00.csv";
}
open($out, ">:encoding(UTF-8)", $OUTPUT_FILE) || die "Cannot open output file $OUTPUT_FILE: $!\n";

print STDERR "Writing to: $OUTPUT_FILE\n";

# Fetch and convert the data
my $cnt=0;

while (my $r = $sth->fetchrow_hashref) {
  if ( $LIMIT && $cnt >= $LIMIT ) {
    $sth->finish;
    last;
  }

  print STDERR Dumper($r) if $PRINT_RECORD;

  if ( $ADD_ID ) {
    if ( $STD_UUID ) {
      $r->{$ADD_ID} = Data::GUID->new->as_string;
    } else {
      $r->{$ADD_ID} = short_guid();
    }
  }

  if ( $HASH_COLUMNS ) {  
    for my $c ( split(",",$HASH_COLUMNS) ) {
      if ( exists($r->{$c}) ) {
        $r->{$c} = hash_column($r->{$c});
      }
    }
  }
  
  print $out join(",",map(map_data($r,$_,$col_types->{$_}),@$columns))."\n";
  
  $cnt++;
  print STDERR "$cnt\r" if ( $cnt%1000 == 0 );
}
print STDERR "\rWrote $cnt records.\n";

# Disconnect
$dbh->disconnect();

# Format a single field value for YDB-compatible CSV output.
# - UTF8/STRING: quoted + URL-encoded
# - All non-text types: first check for forbidden characters, then validate format
sub map_data {
    my ($r, $c, $type) = @_;
    
    # Handle missing (NULL) values
    if (!exists $r->{$c}) {
        return "null";
    }
    
    my $val = $r->{$c};
    
    if (!defined $val) {
        return "null";
    }

    # Textual types: apply YDB-specific escaping and wrap in quotes
    if ($type && $type eq 'UTF8') {
        return '"' . escape($val) . '"';
    }
    if ($type && $type eq 'STRING') {
        return '"' . escape($val,1) . '"';
    }
    if ($type && $type eq 'BOOL') {
        if (lc($val) eq 'false' || lc($val) eq '0') {
            return '0';
        } else {
            return '1';
        }
    }
    if ($type && ($type eq 'DATE' || $type eq 'DATETIME' || $type eq 'TIMESTAMP')) {
        if ($TZ_OFFSET) {
          $val = adjust_datetime_to_utc($val, $TZ_OFFSET, $c);
        } else {
          if ($val =~ /^(\d\d\d\d)-(\d\d)-(\d\d) /) {
              $val =~ s/ /T/;
          }
          if ($val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[ T]\d\d:\d\d:\d\d(.\d\d\d\d\d\d)?$/) {
              $val .="Z";
          }
        }
        return $val;
    }

    # For ALL non-text types: immediately reject if forbidden characters are present
    if ($val =~ /[",\n\r]/) {
        die "Error: non-text column '$c' (type: $type) contains forbidden characters: <$val>\n";
    }

    # Decimal type: must be a valid number (supports negative and fractional)
    if ($type && $type =~ /^DECIMAL/) {
        if ($val !~ /^-?\d+(\.\d+)?$/) {
            die "Error: column '$c' (type: $type) contains non-numeric value: <$val>\n";
        }
        return $val;
    }

    # Signed integer types: INT8, INT16, INT32, INT64
    if ($type && $type =~ /^INT(?:8|16|32|64)$/) {
        if ($val !~ /^-?\d+$/) {
            die "Error: column '$c' (type: $type) contains non-integer value: <$val>\n";
        }
        return $val;
    }

    # Unsigned integer types: UINT8, UINT16, UINT32, UINT64
    if ($type && $type =~ /^UINT(?:8|16|32|64)$/) {
        if ($val !~ /^\d+$/) {
            die "Error: column '$c' (type: $type) contains non-unsigned-integer value: <$val>\n";
        }
        return $val;
    }

    # Floating-point types: FLOAT, DOUBLE (allow scientific notation)
    if ($type && ($type eq 'FLOAT' || $type eq 'DOUBLE')) {
        if ($val !~ /^-?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?$/) {
            die "Error: column '$c' (type: $type) contains invalid float value: <$val>\n";
        }
        return $val;
    }

    # All other non-text types (e.g., TIMESTAMP, DATE, BOOL) pass through
    return $val;
}

sub hash_column {
  my $value=shift;
  
  my $md5_raw = md5(encode('UTF-8', $value));
  if ( $STD_UUID ) {
    return join '-', unpack 'H8 H4 H4 H4 H12', $md5_raw;
  } else {
    return url_friendly(encode_base64($md5_raw, ''));
  }
}

sub escape {
    my $res=shift;
    my $bytes=shift;
    
    return $res if ! defined($res);
    #\x00-\x1F
    $res =~ s/([\x00-\x1F\x22\x23\x25\x26\x27\x28\x29\x2B\x2C\x3A\x3C\x3D\x3E\x3F\x5B\x5C\x5D\x5E\x60\x7B\x7C\x7D\x7F])/
        '%' . sprintf('%02X', ord($1))
    /ge;
    if ( $bytes ) {
    $res =~ s/([\x80-\xFF])/
        '%' . sprintf('%02X', ord($1))
    /ge;
    }
    $res=~s/ /+/g;
    return $res;
}

sub short_guid {
  my $guid=Data::GUID->guid_base64;
	return url_friendly($guid);
}

sub url_friendly {
  my $res = shift;
	$res =~ s/=//g;
	$res =~ tr/\+\//-_/;
	return $res;
}

# Parse YDB protobuf text format (.pb) and extract column names and their types.
# Handles simple types (e.g., type_id: UTF8) and complex types (e.g., decimal_type).
sub extract_column_names_from_proto_text {
    my ($filename) = @_;
    open my $fh, '<', $filename
        or die "Cannot open '$filename': $!";

    my $columns = [];
    my $col_types = {};
    my $in_columns = 0;
    my $brace_depth = 0;
    my $column;
    my $current_type = '';

    while (my $line = <$fh>) {
        # Remove comments (everything after #)
        $line =~ s/#.*$//;

        # Detect start of a 'columns {...}' block
        if ($line =~ /^\s*columns\s*\{/) {
            $in_columns = 1;
            $brace_depth = 1;
            next;
        }

        next unless $in_columns;

        # Track nesting depth of braces
        $brace_depth += () = $line =~ /\{/g;
        $brace_depth -= () = $line =~ /\}/g;

        # Extract column name
        if ($line =~ /\bname:\s*"([^"]+)"/) {
            push @$columns, $1;
            $column = $1;
            $current_type = '';
        }

        # Handle simple type_id (e.g., UTF8, TIMESTAMP)
        if ($line =~ /\btype_id:\s*(\S+)/) {
            $current_type = $1;
        }

        # Handle decimal_type { precision: N; scale: M; }
        if ($line =~ /decimal_type\s*\{/) {
            my $precision = 0;
            my $scale = 0;

            # Try to extract precision and scale from the same line
            if ($line =~ /precision:\s*(\d+)/) {
                $precision = $1;
            }
            if ($line =~ /scale:\s*(\d+)/) {
                $scale = $1;
            }

            # If not found, read subsequent lines until block closes
            while (($precision == 0 || $scale == 0) && $brace_depth > 0) {
                my $next_line = <$fh>;
                last unless defined $next_line;
                $brace_depth += () = $next_line =~ /\{/g;
                $brace_depth -= () = $next_line =~ /\}/g;

                if ($next_line =~ /precision:\s*(\d+)/) {
                    $precision = $1;
                }
                if ($next_line =~ /scale:\s*(\d+)/) {
                    $scale = $1;
                }
            }

            $current_type = "DECIMAL($precision,$scale)";
        }

        # Finalize column type when exiting the top-level block
        if ($brace_depth <= 0) {
            if ($column && $current_type) {
                $col_types->{$column} = $current_type;
            }
            $in_columns = 0;
            $column = '';
            $current_type = '';
        }
    }

    close $fh;
    return ($columns, $col_types);
}

sub read_file {
  my $filename = shift;
  open my $fh, '<', $filename
      or die "Cannot open '$filename': $!\n";

  local $/ = undef;  # enable "slurp mode"
  my $content = <$fh>;
  close $fh;

  return $content;
}

sub local_tz_offset {
  my @local = localtime(time);
  my $local_ts = timelocal(@local);
  my $gm_ts = timegm(@local);
  return $gm_ts - $local_ts;
}

sub parse_tz_offset {
  my ($s) = @_;
  if ($s =~ /^([+-]?)(\d{1,2}):(\d{2})$/) {
      my ($sign, $h, $m) = ($1 || '+', $2, $3);
      my $sec = ($h * 3600 + $m * 60);
      return $sign eq '-' ? -$sec : $sec;
  }
  die "Invalid timezone: $s\n";
}

sub adjust_datetime_to_utc {
    my ($val, $tz_offset_sec, $column) = @_;

    # Case 1: Date + time with fractional seconds (YYYY-MM-DD HH:MI:SS.uuuuuu)
    if ($val =~ /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\.(\d+)Z?/) {
        my ($y, $m, $d, $H, $M, $S, $frac) = ($1, $2, $3, $4, $5, $6, $7);
        # Normalize fractional part to 6 digits (microseconds)
        $frac = substr($frac . "000000", 0, 6);
        my $ts = timegm_nocheck($S, $M, $H, $d, $m - 1, $y - 1900);
        $ts -= $tz_offset_sec;
        my ($sec, $min, $hour, $mday, $mon, $year) = gmtime($ts);
        return sprintf "%04d-%02d-%02dT%02d:%02d:%02d.%sZ",
            $year + 1900, $mon + 1, $mday, $hour, $min, $sec, $frac;
    }

    # Case 2: Date + time without fractional seconds (YYYY-MM-DD HH:MI:SS)
    elsif ($val =~ /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})Z?/) {
        my ($y, $m, $d, $H, $M, $S) = ($1, $2, $3, $4, $5, $6);
        my $ts = timegm_nocheck($S, $M, $H, $d, $m - 1, $y - 1900);
        $ts -= $tz_offset_sec;
        my ($sec, $min, $hour, $mday, $mon, $year) = gmtime($ts);
        return sprintf "%04d-%02d-%02dT%02d:%02d:%02dZ",
            $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
    }

    # Case 3: Date only (YYYY-MM-DD)
    if ($val =~ /^(\d{4})-(\d{2})-(\d{2})/) {
        my ($y, $m, $d) = ($1, $2, $3);
        # Build a fake UTC timestamp from the given components
        my $ts = timegm_nocheck(0, 0, 0, $d, $m - 1, $y - 1900);
        # Adjust: if original time was in a positive TZ, UTC is earlier → subtract offset
        $ts -= $tz_offset_sec;
        my ($sec, $min, $hour, $mday, $mon, $year) = gmtime($ts);
        return sprintf "%04d-%02d-%02dT%02d:%02d:%02dZ",
            $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
    }

    # Unrecognized format – return as-is
    die "Invalid date/time format in column $column: $val\n";
}

sub format_tz_offset {
    my ($seconds) = @_;
    my $sign = $seconds < 0 ? '-' : '+';
    my $abs = abs($seconds);
    my $h = int($abs / 3600);
    my $m = int(($abs % 3600) / 60);
    return sprintf "%s%02d:%02d", $sign, $h, $m;
}